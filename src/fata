#!/usr/bin/env bash

# This file is licensed under the GPLv3. Please see LICENSE for more
# information.

set -o pipefail
set -o nounset
if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace
fi

BANK="banque.json"
QUESTIONS="questions-posées.json"

check_dir() {
    if ! [[ -f ${BANK} ]] || ! [[ -f ${QUESTIONS} ]]; then
	echo "${PWD} ne contient pas de données pour Fata" >&2
	echo "Utilisez 'fata init' pour le transformer en un répertoire exploitable par Fata" >&2
	exit 1
    fi
}

get_focus() {
    pandoc "$1" -t json | jq -r '.blocks | map( select( .t == "Header" and ( .c | .[0] == 1 ) ) ) | map( .c | .[2] | map( if .t == "Str" then .c else " " end ) | add) | .[]'
}

get_periods() {
    pandoc "$1" -t json | jq -r '.blocks | map( select( .t == "Header" and ( .c | .[0] == 2 ) ) ) | map( .c | .[2] | map( if .t == "Str" then .c else " " end ) | add) | .[]'
}

check_md() {
   refperiods=""
   reffile=""
   refset=false
   shopt -s nullglob
   for file in *.md; do
       focus=$(get_focus "${file}")
       if [[ "${focus}" = "" ]]; then
	   # Le fichier ne contient aucun focus.
	   echo "Erreur : le fichier ${file} doit contenir exactement un focus" >&2
	   exit 1
       fi
       number=$(echo -l "${focus}" | wc -l)
       if [[ ${number} -ne 1 ]]; then
	   # Le fichier contient plusieurs focus.
	   echo "Erreur : le fichier ${file} doit contenir exactement un focus" >&2
	   exit 1
       fi
       periods=$(get_periods "${file}")
       if [[ "${refset}" = false ]]; then
	   refperiods="${periods}"
	   reffile="${file}"
	   refset=true
       elif [[ "${refperiods}" != "${periods}" ]]; then
	   expected=$(readarray -t arr <<< "${refperiods}"; printf -v delim  "%s / " "${arr[@]}"; echo "${delim% / }")
	   actual=$(readarray -t arr <<< "${periods}"; printf -v delim  "%s / " "${arr[@]}"; echo "${delim% / }")
	   echo "Erreur : les périodes de ${file} (${actual}) ne correspondent pas à celles de ${reffile} (${expected})" >&2
	   exit 1
       fi
   done
}

list_focuses() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	data=$(get_focus "${file}")
	res+="${data}\n"
    done
    if [[ "${res}" != "" ]]; then
	# shellcheck disable=SC2059
	printf "${res}"
    fi
}

list_periods() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	res=$(get_periods "${file}")
	break
    done
    if [[ "${res}" != "" ]]; then
	# shellcheck disable=SC2059
	printf "${res}\n"
    fi
}

list_keywords() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	res+="$(pandoc "${file}" -t json | jq -r '.blocks | map( select( .t == "Para" ) ) | map( .c | map( select( .t == "Strong" ) | .c | map( if .t == "Str" then .c else " " end ) | add ) ) | .[] | .[]')"
	res+="\n"
    done
    if [[ "${res}" != "" ]]; then
	# shellcheck disable=SC2059
	res=$(printf "${res}" | sort --dictionary-order --ignore-case | uniq)
	printf "${res}\n"
    fi
}

cmd_help()  {
    cmd_version
    echo
    cat <<-_EOF
Commandes :
    fata list (periods|focuses|keywords)
        Liste les périodes, les focus ou les mots-clefs actuellement définis
        dans le projet.
    fata help
        Affiche ce texte.
    fata version
        Affiche la version utilisée.

https://github.com/barsanges/fata
_EOF
}

cmd_version()  {
    echo "Fata 0.0.1"
}

cmd_list()  {
    if [[ -z "${1:-}" ]]; then
	echo "Vous devez fournir un argument à 'fata list' : 'fata list focuses', 'fata list periods' ou 'fata list keywords'" >&2
	exit 1
    fi

    check_md
    case "$1" in
	focuses) shift;	  list_focuses ;;
	periods) shift;	  list_periods ;;
	keywords) shift;  list_keywords ;;
	*)                echo "Argument inconnu '$*'" >&2 ; echo "Les commandes admissibles sont 'fata list focuses', 'fata list periods' ou 'fata list keywords'" >&2 ; exit 1 ;;
    esac
}

cmd_unknown() {
    echo "Commande inconnue '$*'" >&2
    echo "Tapez 'fata help' pour voir la liste des commandes disponibles" >&2
    exit 1
}

if [[ -z "${1:-}" ]]; then
    cmd_help "@"
    exit 0
fi

case "$1" in
	help|--help) shift;		cmd_help "$@" ;;
	version|--version) shift;	cmd_version "$@" ;;
	list) shift;                    check_dir; cmd_list "$@" ;;
	*)				cmd_unknown "$@" ;;
esac
exit 0
