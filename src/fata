#!/usr/bin/env bash

# This file is licensed under the GPLv3. Please see LICENSE for more
# information.

set -o pipefail
set -o nounset
if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace
fi

BANK="banque.json"
QUESTIONS="questions-posées.json"

check_dir() {
    if ! [[ -f ${BANK} ]] || ! [[ -f ${QUESTIONS} ]]; then
	echo "${PWD} ne contient pas de données pour Fata" >&2
	echo "Utilisez 'fata init' pour le transformer en un répertoire exploitable par Fata" >&2
	exit 1
    fi
    check_md
}

get_focus() {
    pandoc "$1" -t json | jq -r '.blocks | map( select( .t == "Header" and ( .c | .[0] == 1 ) ) ) | map( .c | .[2] | map( if .t == "Str" then .c else " " end ) | add) | .[]'
}

get_periods() {
    pandoc "$1" -t json | jq -r '.blocks | map( select( .t == "Header" and ( .c | .[0] == 2 ) ) ) | map( .c | .[2] | map( if .t == "Str" then .c else " " end ) | add) | .[]'
}

check_md() {
   refperiods=""
   reffile=""
   refset=false
   shopt -s nullglob
   for file in *.md; do
       focus=$(get_focus "${file}")
       if [[ "${focus}" = "" ]]; then
	   # Le fichier ne contient aucun focus.
	   echo "Erreur : le fichier ${file} doit contenir exactement un focus" >&2
	   exit 1
       fi
       number=$(echo -l "${focus}" | wc -l)
       if [[ ${number} -ne 1 ]]; then
	   # Le fichier contient plusieurs focus.
	   echo "Erreur : le fichier ${file} doit contenir exactement un focus" >&2
	   exit 1
       fi
       periods=$(get_periods "${file}")
       if [[ "${refset}" = false ]]; then
	   refperiods="${periods}"
	   reffile="${file}"
	   refset=true
       elif [[ "${refperiods}" != "${periods}" ]]; then
	   expected=$(readarray -t arr <<< "${refperiods}"; printf -v delim  "%s / " "${arr[@]}"; echo "${delim% / }")
	   actual=$(readarray -t arr <<< "${periods}"; printf -v delim  "%s / " "${arr[@]}"; echo "${delim% / }")
	   echo "Erreur : les périodes de ${file} (${actual}) ne correspondent pas à celles de ${reffile} (${expected})" >&2
	   exit 1
       fi
   done
}

list_focuses() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	data=$(get_focus "${file}")
	res+="${data}"$'\n'
    done
    if [[ "${res}" != "" ]]; then
	printf '%s\n' "${res}"
    fi
}

list_periods() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	res=$(get_periods "${file}")
	break
    done
    if [[ "${res}" != "" ]]; then
	printf '%s\n' "${res}"
    fi
}

list_keywords() {
    res=""
    shopt -s nullglob
    for file in *.md; do
	res+="$(pandoc "${file}" -t json | jq -r '.blocks | map( select( .t == "Para" ) ) | map( .c | map( select( .t == "Strong" ) | .c | map( if .t == "Str" then .c else " " end ) | add ) ) | .[] | .[]')"
	res="${res}"$'\n'
    done
    if [[ "${res}" != "" ]]; then
	res=$(printf '%s' "${res}" | sort --dictionary-order --ignore-case | uniq)
	printf '%s\n' "${res}"
    fi
}

list_all() {
    content=""
    shopt -s nullglob
    for file in *.md; do
	focus="$(get_focus "${file}")"
	line="[\"${focus}\""
	tmp="$(pandoc "${file}" -t json | jq -r '.blocks | [range(0; length) as $i | select(.[$i].t == "Header" and ( .[$i].c | .[0] == 2 ) ) | $i] | .[]')"
	len="$(pandoc "${file}" -t json | jq -r '.blocks | length')"
	if [[ "${tmp}" != "" ]]; then
	    tmp="0"$'\n'"${tmp}"$'\n'"${len}"
	else
	    tmp="0"$'\n'"${len}"
	fi
	readarray -t periods_indexes <<< "${tmp}"
	last=$((${#periods_indexes[@]}-2))
	for i in $(seq 0 "${last}"); do
	    # Chaque itération correspond à une période.
	    kw="$(pandoc "${file}" -t json | jq -r --argjson a "${periods_indexes[${i}]}" --argjson b "${periods_indexes[${i}+1]}" '.blocks | [ range($a + 1; $b) as $i | .[$i] ] | map( select( .t == "Para" ) ) | map( .c | map( select( .t == "Strong" ) | .c | map( if .t == "Str" then .c else " " end ) | add ) ) | .[] | .[]')"
	    if [[ "${kw}" != "" ]]; then
		kw="$(printf '%s' "${kw}" | sort --dictionary-order --ignore-case | uniq | tr '\n' ',' | sed 's/,$//' | sed 's/,/, /g')"
	    fi
	    line+=", \"${kw}\""
	done
	line+="]"
	content+="${line}"$'\n'
    done
    if [[ "${content}" != "" ]]; then
	header="[\"Focus\", \"Chapeau\""
	periods="$(get_periods "${file}")"
	if [[ "${periods}" != "" ]]; then
	    header+=", "
	    header+="$(printf '%s' "${periods}" | sed 's/.*/"&"/' | tr '\n' ',' | sed 's/,$//' | sed 's/,/, /g')"
	fi
	header+="]"
	table="${header}"$'\n'"${content}"
	res="$(printf '%s' "${table}" | jq -r @tsv | pandoc --from tsv --to markdown)"
	printf '%s\n' "${res}"
    fi
}

cmd_help()  {
    cmd_version
    echo
    cat <<-_EOF
Commandes :
    fata list (periods|focuses|keywords|all)
        Liste les périodes, les focus ou les mots-clefs actuellement définis
        dans le projet, ou tout cela ensemble dans un tableau.
    fata ask
        Pose une question au hasard à partir du fichier 'banque.json'.
    fata help
        Affiche ce texte.
    fata version
        Affiche la version utilisée.

https://github.com/barsanges/fata
_EOF
}

cmd_version()  {
    echo "Fata 0.0.1"
}

cmd_list()  {
    if [[ -z "${1:-}" ]]; then
	echo "Vous devez fournir un argument à 'fata list' : 'fata list focuses', 'fata list periods', 'fata list keywords' ou 'fata list all'" >&2
	exit 1
    fi

    case "$1" in
	focuses) shift;	  list_focuses ;;
	periods) shift;	  list_periods ;;
	keywords) shift;  list_keywords ;;
	all) shift;       list_all ;;
	*)                echo "Argument inconnu '$*'" >&2 ; echo "Les commandes admissibles sont 'fata list focuses', 'fata list periods', 'fata list keywords' ou 'fata list all'" >&2 ; exit 1 ;;
    esac
}

cmd_ask() {
    base_questions="$(jq -r '.[]' banque.json)"

    all_periods="$(list_periods)"
    all_focuses="$(list_focuses)"

    all_questions=""
    if [[ ${all_periods} != "" ]]; then
	# Le dossier contient au moins une période.
	while read -r raw_question; do
	    while read -r period; do
	        while read -r focus; do
		    # shellcheck disable=SC2001
		    question=$(echo "${raw_question}" | sed "s/{{ period }}/'${period}'/g")
		    # shellcheck disable=SC2001
		    question=$(echo "${question}" | sed "s/{{ focus }}/'${focus}'/g")
		    all_questions+="${question}"$'\n'
		done< <(echo -e "${all_focuses}")
	    done< <(echo -e "${all_periods}")
	done < <(echo -e "${base_questions}")
    else
	# Le dossier ne contient aucune période.
	while read -r raw_question; do
	    # On filtre les questions qui contiennent "{{ period }}"
	    if [[ "${raw_question}" != *"{{ period }}"* ]]; then
	        while read -r focus; do
		    # shellcheck disable=SC2001
		    question=$(echo "${raw_question}" | sed "s/{{ focus }}/'${focus}'/g")
		    all_questions+="${question}"$'\n'
		done< <(echo -e "${all_focuses}")
	    fi
	done < <(echo -e "${base_questions}")
    fi

    all_questions=$(echo "${all_questions}" | uniq)
    asked="$(jq -r '.[]' questions-posées.json)"
    askable="$(echo "${all_questions}" | grep -x -v -F -e "${asked}")"
    if [[ ${askable} != "" ]]; then
	last="$(echo "${askable}" | shuf | head -n 1)"
	echo "${last}"
	asked+=$'\n'"${last}"
	echo "${asked}" | jq --raw-input . | jq --slurp . > questions-posées.json
    else
	echo "Aucune question à poser !" >&2
	exit 1
    fi
}

cmd_unknown() {
    echo "Commande inconnue '$*'" >&2
    echo "Tapez 'fata help' pour voir la liste des commandes disponibles" >&2
    exit 1
}

if [[ -z "${1:-}" ]]; then
    cmd_help "@"
    exit 0
fi

case "$1" in
	help|--help) shift;		cmd_help "$@" ;;
	version|--version) shift;	cmd_version "$@" ;;
	list) shift;                    check_dir; cmd_list "$@" ;;
	ask) shift;                     check_dir; cmd_ask ;;
	*)				cmd_unknown "$@" ;;
esac
exit 0
